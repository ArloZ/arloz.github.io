<!DOCTYPE html><html lang="en_US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++面向对象简记 · Arloz Blog</title><meta name="description" content="C++面向对象简记 - Arloz"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Arloz" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++面向对象简记</h1><div class="post-time">Sep 9, 2014</div><div class="post-content"><p>面向对象程序设计（OOP）以对象的概念为中心，对象封装了数据和对数据的操作，对象之间通过消息来相互通信，<br>基于对象的结构化程序能够达到几个目的：</p>
<ul>
<li>1、这种数据和操作之间的强耦合关系是一种对现实世界的仿真，是对现实的一种建模；</li>
<li>2、对象更容易debug，因为对象的封装性使得操作都局限在对象内部，容易跟踪；</li>
<li>3、对象可以隐藏对数据的操作。</li>
</ul>
<p>C++是一种面向对象语言，具有很多面向对象的特性，以下做一些简单的记录。<strong><em>才疏学浅，<br>理解有误的地方还请指正</em></strong></p>
<h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h3><p>C++中的类通过关键字<code>class</code>来定义，类中定义的变量称为成员变量或属性，定义的函数称为成员函数或方法，<br>通过类来定义一个变量称为一个对象实例，类的方法可以通过实例来调用。<br>以下是一个简单的类和对象的定义、方法调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个类</span><br><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    char name[32];</span><br><span class="line">    int age;</span><br><span class="line">public:</span><br><span class="line">    A(char *s="",int i=0)&#123;</span><br><span class="line">        strcpy(name,s);</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line">    void hello()&#123;</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;" is "&lt;&lt;age&lt;&lt;" years old."&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义类的对象实例</span><br><span class="line">A obj1("Bob",12),obj2("Lucy",13);</span><br><span class="line"></span><br><span class="line">// 调用类方法</span><br><span class="line">obj1.hello();</span><br><span class="line">obj2.hello();</span><br></pre></td></tr></table></figure>
<h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>OOL允许创建类的层次关系，所以一个对象不一定是单一类的实例，如下代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 类的继承关系</span><br><span class="line">  */</span></span><br><span class="line"><span class="keyword">class</span> Base&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base()&#123;&#125;</span><br><span class="line">        Base(<span class="keyword">char</span>* s=<span class="string">""</span>, <span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">int</span> ii=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(name,s);</span><br><span class="line">            age = i;</span><br><span class="line">            id = ii;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base construct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base hello: "</span>&lt;&lt;name&lt;&lt;<span class="string">" is "</span>&lt;&lt;age&lt;&lt;<span class="string">" years old."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Student:<span class="keyword">protected</span> Base&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> school[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="keyword">char</span>* s=<span class="string">""</span>,<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> ii=<span class="number">1</span>,<span class="keyword">char</span>* sch=<span class="string">""</span>):Base(s,i,ii)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(school,sch);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Student construct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            Base::hello();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Student hello: "</span>&lt;&lt;name&lt;&lt;<span class="string">" is "</span>&lt;&lt;age&lt;&lt;<span class="string">" years old."</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" in school: "</span>&lt;&lt;school&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"the id is: "&lt;&lt;id&lt;&lt;endl; // ERROR: id is a private member of Base</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Worker:<span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> companay[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Worker(<span class="keyword">char</span>* s=<span class="string">""</span>,<span class="keyword">int</span> i=<span class="number">0</span>, <span class="keyword">int</span> ii=<span class="number">1</span>,<span class="keyword">char</span>* com=<span class="string">""</span>):Base(s,i,ii)&#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(companay,com);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Worker construct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Worker hello: "</span>&lt;&lt;name&lt;&lt;<span class="string">" is "</span>&lt;&lt;age&lt;&lt;<span class="string">" years old."</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" in companay: "</span>&lt;&lt;companay&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类的继承</span></span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"studentA"</span>,<span class="number">23</span>,<span class="number">10000</span>,<span class="string">"tju"</span>)</span></span>;</span><br><span class="line"><span class="function">Worker <span class="title">w</span><span class="params">(<span class="string">"workerB"</span>,<span class="number">32</span>,<span class="number">10001</span>,<span class="string">"baidu"</span>)</span></span>;</span><br><span class="line">w.hello();</span><br><span class="line">s.hello();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;w.name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;s.name&lt;&lt;endl;// ERROR: Student is protected extend from Base class</span></span><br></pre></td></tr></table></figure></p>
<p>类Base称为基类或超类，其他的类称为子类或派生类，因为他们都是从基类继承而来，在从基类继承的时候可以指定为<br>protected或者public继承，子类继承了基类的所有数据成员和成员函数，不需要重复定义，同时也可以定义自己的<br>数据成员和成员函数。类中的成员(数据成员和成员函数)的访问限制如下：</p>
<ul>
<li>public成员：类自身、子类和类的对象实例可以访问</li>
<li>protected成员：类自身和子类可以访问</li>
<li>private成员：仅类自身可以访问</li>
</ul>
<p>子类继承父类之后，父类的成员的private、protected、public修饰的变化：</p>
<ul>
<li>public继承：父类的所有成员保持原修饰不变</li>
<li>protected继承：父类的public修饰的成员变为protected修饰，其他的保持不变</li>
<li>private继承：父类的所有成员变为private修饰</li>
</ul>
<h3 id="3-指针"><a href="#3-指针" class="headerlink" title="3.指针"></a>3.指针</h3><p>形象的我们可以把程序中的变量看做一个不为空的盒子，在定义时由程序员填上一些内容或者由系统填上默认的内容。<br>这样一个变量就至少具有了两种属性：内容（变量的值）和位置（变量的内存地址），内容可以是数字、字符或复杂的数据结构，<br>当然内容也可以是另一个变量的位置，具有这种内容的变量就称为指针。<br>举个例子，声明变量如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">15</span>, j, *p, *q;</span><br></pre></td></tr></table></figure>
<p>其中i,j都是数值型的变量，p,q都是指向数值的指针。将变量i的地址赋值给指针p：<code>p = &amp;i</code>，此时p指向变量i在内存中的存储地址，<br>该地址处存储的值为15，同时可以给指针q赋值：<code>q = p</code>，此时将p指向的地址赋值给了q，这样q和p指向同样的位置。通过指针修改<br>其指向变量的值可以：<code>*p = 20</code>，此时变量i的值为20。</p>
<p>上面指针是指向了一个整数变量内存块，同样指针也可以指向一个动态创建的数据结构。在C++中数组的大小是必须提前定义的，如：<br><code>int a[5],*p;</code>。有很多情况下是不能够提前知道数组大小的，这样就需要能够在程序运行时动态的开辟数组的大小，在C++中可以<br>使用new关键字，如：<code>int* a = new int[n]</code>，这样分配了n个int空间的数组，当不再使用该数组时需要释放分配的存储空间，如：<br><code>delete [] p;</code>，这里的括号表示p是指向一个数组。</p>
<p>当将数据从一个对象复制到另一个对象的时候，包含指针数据成员的需要做一些特殊的处理，否则就会有一些问题。如下定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 指针和复制构造函数</span><br><span class="line"> */</span><br><span class="line">struct Node&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    Node(char* s="",int a=0)&#123;</span><br><span class="line">        name = strdup(s);</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 指针和复制构造函数</span><br><span class="line">Node node1("kobe",20),node2(node1);</span><br><span class="line">cout&lt;&lt;"node1 "&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"node2 "&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;</span><br><span class="line">// output</span><br><span class="line">// node1 kobe 20</span><br><span class="line">// node2 kobe 20</span><br><span class="line">strcpy(node1.name,"john");</span><br><span class="line">node1.age = 23;</span><br><span class="line">cout&lt;&lt;"node1 "&lt;&lt;node1.name&lt;&lt;" "&lt;&lt;node1.age&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"node2 "&lt;&lt;node2.name&lt;&lt;" "&lt;&lt;node2.age&lt;&lt;endl;</span><br><span class="line">// output</span><br><span class="line">// node1 john 23</span><br><span class="line">// node2 john 20</span><br></pre></td></tr></table></figure>
<p>由上可知，改变了node1的name值的同时也改变了node2的name的值，这是因为在定义node2的时候<code>Node node2(node1);</code>，将node1的数据成员name的值（也就是指向name字符串的地址）赋值给了node2的name，这样node1和node2的数据成员name则指向了同样的内存地址，当修改node1的name指向的字符串时<code>strcpy(node1.name,&quot;john&quot;)</code>，node2的name指向的值也随着改变了。要解决这个问题就需要在Node的构造函数中做一些修改，如下，这样node1复制给node2的数据成员name就是其指向的值而不是其保存的地址。注意，常见的赋值操作<code>=</code>,也存在这样的问题，因此需要重载赋值操作符。同样，对于指针数据成员，类的析构函数也需要做相应的处理，在析构函数中需要调用<code>delete</code>删除指针数据成员所指向的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Node(<span class="keyword">char</span>* s=<span class="string">""</span>,<span class="keyword">int</span> a=<span class="number">0</span>)&#123;</span><br><span class="line">        name = strdup(s);</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数的指针复制</span></span><br><span class="line">    Node(<span class="keyword">const</span> Node &amp;n)&#123;</span><br><span class="line">        name = strdup(n.name);</span><br><span class="line">        age = n.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指针数据成员的赋值操作</span></span><br><span class="line">    Node&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Node&amp; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;n)&#123; <span class="comment">// no assignment to it self</span></span><br><span class="line">            <span class="keyword">if</span>(name != null)</span><br><span class="line">                <span class="keyword">delete</span> [] name;</span><br><span class="line">            name = strdup(n.name);</span><br><span class="line">            age = n.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h3><p>多态性指同样的函数名称表示很多的函数，这些函数是不同对象的成员函数。如下例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 多态性</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> ClassA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello in ClassA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"bye in ClassA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> ClassB&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello in ClassB"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"bye in ClassB"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> ClassC&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"hi in ClassC"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态性</span></span><br><span class="line">ClassA obja,*p;</span><br><span class="line">ClassB objb;</span><br><span class="line">ClassC objc;</span><br><span class="line"></span><br><span class="line">p = &amp;obja;</span><br><span class="line">p-&gt;hello();</span><br><span class="line">p-&gt;bye();</span><br><span class="line"></span><br><span class="line">p = (ClassA*) &amp;objb;</span><br><span class="line">p-&gt;hello();</span><br><span class="line">p-&gt;bye();</span><br><span class="line"></span><br><span class="line">p = (ClassA*) &amp;objc;</span><br><span class="line"><span class="comment">//p-&gt;hello(); // ERROR: segmentation fault</span></span><br><span class="line">p-&gt;bye();</span><br><span class="line"><span class="comment">//p-&gt;hi();// ERROR: no member named 'hi' in ClassA</span></span><br></pre></td></tr></table></figure></p>
<p>分别声明了类ClassA、ClassB、ClassC的三个对象obja、objb、objc和一个ClassA类型的指针p，首先将obja对象地址赋值给指针p，<br>这样通过p调用函数hello和bye均为分别调用ClassA的函数成员，这也是常见的一种使用方式；其次将objb对象赋值给指针p，这样通过<br>p调用hello和bye函数时，由于hello函数是定义为virtual函数的，此时将根据当前p执行的对象类型来决定调用哪个类的方法，<br>此时p是指向的ClassB类型，所以调用ClassB中的hello，而由于bye函数不是虚函数，则其在编译时已经确定了，p声明时是ClassA类型，<br>所以调用ClassA中的函数bye；最后将objc对方赋值给指针p，此时由于ClassC中没有定义虚函数hello，当程序执行到此处时，找不到ClassC的hello函数<br>则会出现segmentation fault错误，调用bye函数则是在编译时已经确定的调用ClassA中的bye函数，调用ClassC中定义的hi函数时，<br>由于p指针是ClassA类型，所以在编译时已经确定了调用ClassA中的hi函数，由于ClassA没有定义改函数，则在编译会提示错误。</p>
<p>多态性是OOP中的一种强大且复杂的功能，通过该特性可以将同一个消息发送给很多不同的对象，而不需要指定如何处理消息，也不需要指定对象的类型。</p>
<h3 id="5-标准模板库STL"><a href="#5-标准模板库STL" class="headerlink" title="5.标准模板库STL"></a>5.标准模板库STL</h3><p>C++是一种面向对象的程序设计语言，得到了广泛的应用，其中也包含了程序员最常用的一些数据结构和算法，<br>这个库就是<a href="http://zh.wikipedia.org/wiki/标准模板库" target="_blank" rel="external">标准模板库STL</a>。<br>这个库包含了3中通用的实体：容器、迭代器和算法。</p>
<p><strong><em>参考：《数据结构与算法—-C++版(第三版)》，清华大学出版社</em></strong></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/09/14/linklist/" class="prev">上一篇</a><a href="/2014/06/27/upload-file-tornado/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'arloz';
var disqus_identifier = '2014/09/09/cpp-orient/';
var disqus_title = 'C++面向对象简记';
var disqus_url = 'http://arloz.github.io/2014/09/09/cpp-orient/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//arloz.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://arloz.github.io">Arloz</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>